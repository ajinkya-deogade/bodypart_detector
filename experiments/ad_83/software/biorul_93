public List<LEDStimulus> determineStimulus(List<LarvaFrameData> frameHistory,
                                               LarvaBehaviorParameters behaviorParameters) {

        final LarvaFrameData frameData = frameHistory.get(0);
        final long captureTime = frameData.getTime();

        List<LEDStimulus> stimulusList;

        if (captureTime >= noStimulusStartDuration) {

            if (frameData.isRunning()) {

                if (lastSampleTime == null) {

                    // if the larva is truly running, apply ramp

                    if (rampStartTime == null) {
                        rampStartTime = captureTime;
                        rampStartIntensity = currentIntensity;

                        // select filter function at start of each run
                        if (randomRampFilterFunctionSelector.nextBoolean()) {
                            currentRampFilterFunction = forwardRampFilterFunction;
                            logRuleData(captureTime, RuleData.RAMP_FILTER_FUNCTION_NAME, RuleData.PRIMARY_NAME);
                        } else {
                            currentRampFilterFunction = alternateForwardRampFilterFunction;
                            logRuleData(captureTime, RuleData.RAMP_FILTER_FUNCTION_NAME, RuleData.ALTERNATE_NAME);
                        }
                    }

                    final long timeSinceRampStart = captureTime - rampStartTime;
                    currentIntensity = rampStartIntensity + forwardRampFunction.getValue(timeSinceRampStart);

                    if (timeSinceRampStart < forwardRampFilterDuration) {
                        currentIntensity = currentIntensity + currentRampFilterFunction.getValue(frameData);
                    }

                } else {

                    // not sure if larva is truly running, so just maintain current intensity
                    endSamplingBoutAsNeeded(frameData, captureTime);

                }

            } else if (isSampling(frameData)) {

               if (lastSampleTime == null) { // start sampling bout

                   rampStartTime = null;
                   currentSampleBaseIntensity = currentIntensity;

                   boutCount++;
                   if (boutCount > boutsBeforeReset) {
                       boutCount = 0;

                       logRuleData(captureTime, "bout reset", String.valueOf(currentIntensity));
                       currentIntensity = baselineIntensityPercentage.getValue();
                   }

                   logRuleData(captureTime, "sampling bout", "start");
                   setCurrentSamplingFunction(captureTime);

               }

                lastSampleTime = captureTime;

                final double intensityAddend = currentSamplingFunction.getValue(frameData);
                currentIntensity = currentSampleBaseIntensity + intensityAddend;

            } else if (lastSampleTime != null) { // maintain current intensity

                endSamplingBoutAsNeeded(frameData, captureTime);

            } // else maintain current intensity

            if ((currentIntensity < resetMinimumIntensityPercentage) ||
                (currentIntensity > resetMaximumIntensityPercentage)) {

                logRuleData(captureTime, RuleData.BOUNDS_RESET, String.valueOf(currentIntensity));
                currentIntensity = baselineIntensityPercentage.getValue();
                rampStartTime = captureTime; // reset ramp as well
                rampStartIntensity = currentIntensity;
            }

            stimulusList = getStimulusList(currentIntensity);
            intensityFilterFunctionList.applyValues(frameData, stimulusList, 0.0);

        } else {

            stimulusList = ZERO_INTENSITY_FOR_ONE_SECOND;

        }

        return stimulusList;
    }

    private void endSamplingBoutAsNeeded(final LarvaFrameData frameData,
                                         final long captureTime) {
        final long elapsedSinceLastSample = frameData.getTime() - lastSampleTime;
        if (elapsedSinceLastSample >= maintainSamplingModeDuration) {
            lastSampleTime = null;
            logRuleData(captureTime, "sampling bout", "stop");
        }
    }

    private boolean isSampling(final LarvaFrameData frameData) {
        return frameData.isCasting() || (includeTurnsInSampling && frameData.isTurning());
    }

    private void setCurrentSamplingFunction(long captureTime) {
        if ((numberOfAdditiveSamplingFunctions > 1) && (numberOfAdditiveSamplingFunctions < 4)) {
            final KinematicVariableFunction[] functions = { samplingFunction, samplingFunction2, samplingFunction3 };
            final int functionIndex = randomSamplingFunctionSelector.nextInt(numberOfAdditiveSamplingFunctions);
            currentSamplingFunction = functions[functionIndex];
            logRuleData(captureTime, RuleData.SAMPLING_FUNCTION_NAME, String.valueOf(functionIndex));
        } else {
            currentSamplingFunction = samplingFunction;
        }
    }
}